# 합리적인 엔지니어를 위한 캐싱 가이드 (Rational Caching)

캐싱은 성능을 높이는 마법이 아니라, **복잡성과 정합성을 담보로 빌려온 성능**입니다. 이 문서는 캐시 도입을 고민하는 엔지니어가 유지해야 할 비판적 시각과 실무적인 컨벤션을 정리합니다.

## 1. 캐시 도입 전의 체크리스트 (The Last Resort)

캐시는 "성능이 안 나오니까 일단 넣자"가 되어서는 안 됩니다. 도입 전 아래 단계를 완료했는지 확인하세요.

1.  **SQL 튜닝**: 실행 계획(Explain)을 확인하고 적절한 인덱스를 설정했는가?
2.  **Batch Loading**: N+1 문제를 해결하여 쿼리 횟수 자체를 줄였는가?
3.  **Read Replica**: DB 읽기 전용 복제본을 통해 부하를 분산했는가?
4.  **Local Caching**: 서버 메모리(Caffeine 등)만으로 해결 가능한 수준인가?

위 단계를 거쳤음에도 불구하고 **네트워크 지연 시간(Latency)**이나 **DB CPU 점유율**이 해결되지 않을 때 비로소 분산 캐시(Redis 등)를 고려합니다.

## 2. 언제 사용하는 것이 합리적인가?

### 2.1 데이터 성격에 따른 분류
- **자주 조회되고 거의 변하지 않는 데이터** (Best): 공지사항, 설정 값, 사용자 등급 정보.
- **조회는 잦으나 자주 변하는 데이터** (Warning): 게시글 조회수, 댓글 수. (정합성 보장 전략이 복잡해짐)
- **절대 틀리면 안 되는 데이터** (Never): 계좌 잔액, 결제 정보.

### 2.2 기술적 상황
- **비싼 계산**: 여러 테이블을 JOIN 하고 집계 함수를 써서 1초 이상 걸리는 쿼리 결과.
- **외부 시스템 의존**: 외부 API 호출이 느리거나 호출 당 비용이 발생할 때.
- **Thundering Herd 방지**: 특정 기간(이벤트 등)에 특정 데이터로 트래픽이 몰릴 때 DB 보호 목적.

## 3. 실무 컨벤션 및 관리 전략

### 3.1 키 설계 (Key Naming)
- 패턴: `서비스:도메인:식별자`
- 예시: `playground:user:profile:123`
- 이유: Redis 내에서 키가 섞이는 것을 방지하고 용도를 한눈에 파악하기 위함.

### 3.2 만료 전략 (Expiration/TTL)
- **반드시 모든 키에 TTL을 설정**하세요. 무기한 캐시는 시스템의 시한폭탄입니다.
- 데이터의 중요도에 따라 5분~1시간 정도로 설정하고, 정합성이 중요할수록 짧게 가져갑니다.

### 3.3 캐시 전략 (Cache Patterns)
- **Cache-Aside (Standard)**: 
  1. 앱이 캐시 확인 -> 있으면 반환.
  2. 없으면 DB 조회 -> 캐시에 저장 -> 반환.
  *특징: 앱이 주도권을 가지며, 캐시 장애 시 DB로 폴백이 가능함.*
- **Write-Around**: 데이터 저장 시에는 DB만 업데이트하고, 읽을 때만 캐시를 채움. (데이터 유실 위험 적음)

## 4. 데이터 정합성 관리

캐시와 DB의 데이터가 달라지는 것은 피할 수 없습니다. 이를 관리하는 두 가지 방법:
1.  **TTL 기반**: 시간이 지나면 자동으로 사라지게 함. (느슨한 정합성)
2.  **삭제 기반 (Explicit Purge)**: DB 데이터가 수정/삭제될 때 연관된 캐시 키를 명시적으로 삭제. (강한 정합성)

## 5. 엔지니어의 마음가짐
"캐시가 없어도 시스템은 느릴지언정 정상적으로 돌아가야 한다." 
캐시는 **Optional Optimization**이어야지, **Hard Dependency**가 되어서는 안 됩니다.
