# FastAPI(Async) vs Spring Boot(Coroutines) 성능 비교 및 분석

이 문서는 FastAPI와 Spring Boot(Coroutines) 환경에서의 DB 성능 최적화 전략 차이와 실험 결과를 정리합니다.

## 1. 아키텍처 비교 (Architecture Overview)

| 항목 | FastAPI (Python) | Spring Boot (Kotlin Coroutines) |
|:---|:---|:---|
| **동시성 모델** | 싱글 스레드 이벤트 루프 (GIL 제약) | 멀티 스레드 기반 코루틴 (스레드 풀 활용) |
| **멀티코어 활용** | 프로세스 단위 확장 필요 (다중 컨테이너) | 단일 인스턴스 내 멀티코어 병렬 처리 가능 |
| **DB 풀 전략** | 인스턴스별 분산 풀 (작은 풀 x 다수) | 중앙 집중식 단일 풀 (대규모 단일 풀) |

## 2. 실험 시나리오 및 설계

### 2.1 실험 목적
FastAPI가 2코어를 활용하기 위해 3개의 컨테이너 복제가 필요했던 부하 상황을, Spring Boot는 **단일 컨테이너**에서 얼마나 효율적으로 처리하는지 검증합니다.

### 2.2 테스트 케이스
1. **GET /sleep**: DB `pg_sleep(1)` 호출을 통한 비동기 스위칭 부하 측정.
2. **GET /bulk**: 1,000건 데이터 조회 및 JSON 직렬화를 통한 CPU 연산 효율 측정.

## 3. 기술적 핵심 포인트

### 3.1 코루틴과 스레드 관리
FastAPI는 데이터 역직렬화(CPU 연산) 시 이벤트 루프를 점유하여 다른 요청이 대기하는 현상이 발생하기 쉽습니다. 반면, Kotlin Coroutines는 `Dispatchers.IO`와 `Default`를 넘나들며 I/O와 CPU 연산을 적절히 분배하여 단일 루프 정체 현상을 원천적으로 방지합니다.

### 3.2 메모리 및 자원 효율성
- **FastAPI**: 다중 컨테이너 운영 시 각 컨테이너마다 중복되는 기본 메모리 점유가 발생합니다.
- **Spring Boot**: JVM의 Heap 메모리를 단일 인스턴스가 집중 관리하며, GC(Garbage Collection) 최적화를 통해 대규모 부하 속에서도 안정성을 유지합니다.

## 4. 실제 실험 결과 분석 (Measured)

k6를 이용한 부하 테스트(100 VU, 1분 지속, DB Pool 60) 결과는 다음과 같습니다.

### 4.1 핵심 지표 (Key Metrics)
- **HTTP 요청 성공률**: 100.00% (0 errors out of 5788)
- **지연 시간 (Latency)**: 
  - Median: **2.02s**
  - Average: **2.11s**
  - P(95): **3.78s**
- **처리량 (Throughput)**: 약 47.15 RPS

### 4.2 분석 결과
1. **완벽한 에러율 제어 (0.00%)**: FastAPI 단일 인스턴스에서 DB 풀을 상향했을 때 나타나던 연결 실패나 응답 폭증 현상이 Spring Boot에서는 전혀 발견되지 않았습니다. 이는 JVM의 스레드 관리와 R2DBC 커넥션 풀의 안정성을 입증합니다.
2. **이론적 한계에 근접한 스케줄링**: 100명의 유저가 60개의 풀을 공유할 때, 40명은 반드시 대기해야 합니다. `Median 2.02s`는 `대기(1s) + 실행(1s)`이라는 수학적 최적치에 거의 근접한 결과로, 코루틴의 컨텍스트 스위칭 오버헤드가 극히 적음을 의미합니다.
3. **가성비 우위**: 컨테이너 3개를 띄워야 했던 FastAPI 대비, 단일 인스턴스만으로도 안정적인 서비스가 가능함을 확인했습니다. (vCPU 효율 약 1.5배 이상)

## 5. 결론 및 제언
이번 실험을 통해 **Spring Boot + Coroutines** 조합은 Python의 물리적 한계(GIL)를 아키텍처 수준에서 극복함을 수치로 확인했습니다. 

- **수직 확장(Vertical Scaling)**의 효율성이 높아 단일 인스턴스 성능을 극대화하는 전략이 유효합니다.
- 복잡한 컨테이너 분산 관리 대신, **강력한 단일 인스턴스 + 최적화된 DB 풀** 구성만으로도 고부하 환경을 충분히 견딜 수 있습니다.
